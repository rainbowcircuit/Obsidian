{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/OutlineNode.js"],
  "sourcesContent": ["import { DepthTexture, FloatType, RenderTarget, Vector2, TempNode, QuadMesh, NodeMaterial, RendererUtils, NodeUpdateType } from 'three/webgpu';\nimport { Loop, int, exp, min, float, mul, uv, vec2, vec3, Fn, textureSize, orthographicDepthToViewZ, screenUV, nodeObject, uniform, vec4, passTexture, texture, perspectiveDepthToViewZ, positionView, reference } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nconst _size = /*@__PURE__*/ new Vector2();\nconst _BLUR_DIRECTION_X = /*@__PURE__*/ new Vector2( 1.0, 0.0 );\nconst _BLUR_DIRECTION_Y = /*@__PURE__*/ new Vector2( 0.0, 1.0 );\n\nlet _rendererState;\n\n/**\n * Post processing node for rendering outlines around selected objects. The node\n * gives you great flexibility in composing the final outline look depending on\n * your requirements.\n * ```js\n * const postProcessing = new THREE.PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * // outline parameter\n *\n * const edgeStrength = uniform( 3.0 );\n * const edgeGlow = uniform( 0.0 );\n * const edgeThickness = uniform( 1.0 );\n * const visibleEdgeColor = uniform( new THREE.Color( 0xffffff ) );\n * const hiddenEdgeColor = uniform( new THREE.Color( 0x4e3636 ) );\n *\n * outlinePass = outline( scene, camera, {\n * \tselectedObjects,\n * \tedgeGlow,\n * \tedgeThickness\n * } );\n *\n * // compose custom outline\n *\n * const { visibleEdge, hiddenEdge } = outlinePass;\n * const outlineColor = visibleEdge.mul( visibleEdgeColor ).add( hiddenEdge.mul( hiddenEdgeColor ) ).mul( edgeStrength );\n *\n * postProcessing.outputNode = outlineColor.add( scenePass );\n * ```\n *\n * @augments TempNode\n * @three_import import { outline } from 'three/addons/tsl/display/OutlineNode.js';\n */\nclass OutlineNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'OutlineNode';\n\n\t}\n\n\t/**\n\t * Constructs a new outline node.\n\t *\n\t * @param {Scene} scene - A reference to the scene.\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t * @param {Object} params - The configuration parameters.\n\t * @param {Array<Object3D>} [params.selectedObjects] - An array of selected objects.\n\t * @param {Node<float>} [params.edgeThickness=float(1)] - The thickness of the edges.\n\t * @param {Node<float>} [params.edgeGlow=float(0)] - Can be used for an animated glow/pulse effects.\n\t * @param {number} [params.downSampleRatio=2] - The downsample ratio.\n\t */\n\tconstructor( scene, camera, params = {} ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tconst {\n\t\t\tselectedObjects = [],\n\t\t\tedgeThickness = float( 1 ),\n\t\t\tedgeGlow = float( 0 ),\n\t\t\tdownSampleRatio = 2\n\t\t} = params;\n\n\t\t/**\n\t\t * A reference to the scene.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera the scene is rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * An array of selected objects.\n\t\t *\n\t\t * @type {Array<Object3D>}\n\t\t */\n\t\tthis.selectedObjects = selectedObjects;\n\n\t\t/**\n\t\t * The thickness of the edges.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.edgeThicknessNode = nodeObject( edgeThickness );\n\n\t\t/**\n\t\t * Can be used for an animated glow/pulse effect.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.edgeGlowNode = nodeObject( edgeGlow );\n\n\t\t/**\n\t\t * The downsample ratio.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2\n\t\t */\n\t\tthis.downSampleRatio = downSampleRatio;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t// render targets\n\n\t\t/**\n\t\t * The render target for the depth pre-pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetDepthBuffer = new RenderTarget();\n\t\tthis._renderTargetDepthBuffer.depthTexture = new DepthTexture();\n\t\tthis._renderTargetDepthBuffer.depthTexture.type = FloatType;\n\n\t\t/**\n\t\t * The render target for the mask pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetMaskBuffer = new RenderTarget();\n\n\t\t/**\n\t\t * The render target for the mask downsample.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetMaskDownSampleBuffer = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t/**\n\t\t * The first render target for the edge detection.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetEdgeBuffer1 = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t/**\n\t\t * The second render target for the edge detection.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetEdgeBuffer2 = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t/**\n\t\t * The first render target for the blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetBlurBuffer1 = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t/**\n\t\t * The second render target for the blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetBlurBuffer2 = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t/**\n\t\t * The render target for the final composite.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetComposite = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t// uniforms\n\n\t\t/**\n\t\t * Represents the near value of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ReferenceNode<float>}\n\t\t */\n\t\tthis._cameraNear = reference( 'near', 'float', camera );\n\n\t\t/**\n\t\t * Represents the far value of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ReferenceNode<float>}\n\t\t */\n\t\tthis._cameraFar = reference( 'far', 'float', camera );\n\n\t\t/**\n\t\t * Uniform that represents the blur direction of the pass.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._blurDirection = uniform( new Vector2() );\n\n\t\t/**\n\t\t * Texture node that holds the data from the depth pre-pass.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._depthTextureUniform = texture( this._renderTargetDepthBuffer.depthTexture );\n\n\t\t/**\n\t\t * Texture node that holds the data from the mask pass.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._maskTextureUniform = texture( this._renderTargetMaskBuffer.texture );\n\n\t\t/**\n\t\t * Texture node that holds the data from the mask downsample pass.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._maskTextureDownsSampleUniform = texture( this._renderTargetMaskDownSampleBuffer.texture );\n\n\t\t/**\n\t\t * Texture node that holds the data from the first edge detection pass.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._edge1TextureUniform = texture( this._renderTargetEdgeBuffer1.texture );\n\n\t\t/**\n\t\t * Texture node that holds the data from the second edge detection pass.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._edge2TextureUniform = texture( this._renderTargetEdgeBuffer2.texture );\n\n\t\t/**\n\t\t * Texture node that holds the current blurred color data.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._blurColorTextureUniform = texture( this._renderTargetEdgeBuffer1.texture );\n\n\t\t// constants\n\n\t\t/**\n\t\t * Visible edge color.\n\t\t *\n\t\t * @private\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis._visibleEdgeColor = vec3( 1, 0, 0 );\n\n\t\t/**\n\t\t * Hidden edge color.\n\t\t *\n\t\t * @private\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis._hiddenEdgeColor = vec3( 0, 1, 0 );\n\n\t\t// materials\n\n\t\t/**\n\t\t * The material for the depth pre-pass.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._depthMaterial = new NodeMaterial();\n\t\tthis._depthMaterial.fragmentNode = vec4( 0, 0, 0, 1 );\n\t\tthis._depthMaterial.name = 'OutlineNode.depth';\n\n\t\t/**\n\t\t * The material for preparing the mask.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._prepareMaskMaterial = new NodeMaterial();\n\t\tthis._prepareMaskMaterial.name = 'OutlineNode.prepareMask';\n\n\t\t/**\n\t\t * The copy material\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._materialCopy = new NodeMaterial();\n\t\tthis._materialCopy.name = 'OutlineNode.copy';\n\n\t\t/**\n\t\t * The edge detection material.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._edgeDetectionMaterial = new NodeMaterial();\n\t\tthis._edgeDetectionMaterial.name = 'OutlineNode.edgeDetection';\n\n\t\t/**\n\t\t * The material that is used to render in the blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._separableBlurMaterial = new NodeMaterial();\n\t\tthis._separableBlurMaterial.name = 'OutlineNode.separableBlur';\n\n\t\t/**\n\t\t * The material that is used to render in the blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._separableBlurMaterial2 = new NodeMaterial();\n\t\tthis._separableBlurMaterial2.name = 'OutlineNode.separableBlur2';\n\n\t\t/**\n\t\t * The final composite material.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._compositeMaterial = new NodeMaterial();\n\t\tthis._compositeMaterial.name = 'OutlineNode.composite';\n\n\t\t/**\n\t\t * A set to cache selected objects in the scene.\n\t\t *\n\t\t * @private\n\t\t * @type {Set<Object3D>}\n\t\t */\n\t\tthis._selectionCache = new Set();\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._renderTargetComposite.texture );\n\n\t}\n\n\t/**\n\t * A mask value that represents the visible edge.\n\t *\n\t * @return {Node<float>} The visible edge.\n\t */\n\tget visibleEdge() {\n\n\t\treturn this.r;\n\n\t}\n\n\t/**\n\t * A mask value that represents the hidden edge.\n\t *\n\t * @return {Node<float>} The hidden edge.\n\t */\n\tget hiddenEdge() {\n\n\t\treturn this.g;\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._renderTargetDepthBuffer.setSize( width, height );\n\t\tthis._renderTargetMaskBuffer.setSize( width, height );\n\t\tthis._renderTargetComposite.setSize( width, height );\n\n\t\t// downsample 1\n\n\t\tlet resx = Math.round( width / this.downSampleRatio );\n\t\tlet resy = Math.round( height / this.downSampleRatio );\n\n\t\tthis._renderTargetMaskDownSampleBuffer.setSize( resx, resy );\n\t\tthis._renderTargetEdgeBuffer1.setSize( resx, resy );\n\t\tthis._renderTargetBlurBuffer1.setSize( resx, resy );\n\n\t\t// downsample 2\n\n\t\tresx = Math.round( resx / 2 );\n\t\tresy = Math.round( resy / 2 );\n\n\t\tthis._renderTargetEdgeBuffer2.setSize( resx, resy );\n\t\tthis._renderTargetBlurBuffer2.setSize( resx, resy );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { camera, scene } = this;\n\n\t\t_rendererState = RendererUtils.resetRendererAndSceneState( renderer, scene, _rendererState );\n\n\t\t//\n\n\t\tconst size = renderer.getDrawingBufferSize( _size );\n\t\tthis.setSize( size.width, size.height );\n\n\t\t//\n\n\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\tthis._updateSelectionCache();\n\n\t\tconst currentSceneName = scene.name;\n\n\t\t// 1. Draw non-selected objects in the depth buffer\n\n\t\tscene.overrideMaterial = this._depthMaterial;\n\n\t\trenderer.setRenderTarget( this._renderTargetDepthBuffer );\n\t\trenderer.setRenderObjectFunction( ( object, ...params ) => {\n\n\t\t\tif ( this._selectionCache.has( object ) === false ) {\n\n\t\t\t\trenderer.renderObject( object, ...params );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tscene.name = 'Outline [ Non-Selected Objects Pass ]';\n\t\trenderer.render( scene, camera );\n\n\t\t// 2. Draw only the selected objects by comparing the depth buffer of non-selected objects\n\n\t\tscene.overrideMaterial = this._prepareMaskMaterial;\n\n\t\trenderer.setRenderTarget( this._renderTargetMaskBuffer );\n\t\trenderer.setRenderObjectFunction( ( object, ...params ) => {\n\n\t\t\tif ( this._selectionCache.has( object ) === true ) {\n\n\t\t\t\trenderer.renderObject( object, ...params );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tscene.name = 'Outline [ Selected Objects Pass ]';\n\t\trenderer.render( scene, camera );\n\n\t\t//\n\n\t\trenderer.setRenderObjectFunction( _rendererState.renderObjectFunction );\n\n\t\tthis._selectionCache.clear();\n\n\t\tscene.name = currentSceneName;\n\n\t\t// 3. Downsample to (at least) half resolution\n\n\t\t_quadMesh.material = this._materialCopy;\n\t\t_quadMesh.name = 'Outline [ Downsample ]';\n\t\trenderer.setRenderTarget( this._renderTargetMaskDownSampleBuffer );\n\t\t_quadMesh.render( renderer );\n\n\t\t// 4. Perform edge detection (half resolution)\n\n\t\t_quadMesh.material = this._edgeDetectionMaterial;\n\t\t_quadMesh.name = 'Outline [ Edge Detection ]';\n\t\trenderer.setRenderTarget( this._renderTargetEdgeBuffer1 );\n\t\t_quadMesh.render( renderer );\n\n\t\t// 5. Apply blur (half resolution)\n\n\t\tthis._blurColorTextureUniform.value = this._renderTargetEdgeBuffer1.texture;\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_X );\n\n\t\t_quadMesh.material = this._separableBlurMaterial;\n\t\t_quadMesh.name = 'Outline [ Blur Half Resolution ]';\n\t\trenderer.setRenderTarget( this._renderTargetBlurBuffer1 );\n\t\t_quadMesh.render( renderer );\n\n\t\tthis._blurColorTextureUniform.value = this._renderTargetBlurBuffer1.texture;\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_Y );\n\n\t\trenderer.setRenderTarget( this._renderTargetEdgeBuffer1 );\n\t\t_quadMesh.render( renderer );\n\n\t\t// 6. Apply blur (quarter resolution)\n\n\t\tthis._blurColorTextureUniform.value = this._renderTargetEdgeBuffer1.texture;\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_X );\n\n\t\t_quadMesh.material = this._separableBlurMaterial2;\n\t\t_quadMesh.name = 'Outline [ Blur Quarter Resolution ]';\n\t\trenderer.setRenderTarget( this._renderTargetBlurBuffer2 );\n\t\t_quadMesh.render( renderer );\n\n\t\tthis._blurColorTextureUniform.value = this._renderTargetBlurBuffer2.texture;\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_Y );\n\n\t\trenderer.setRenderTarget( this._renderTargetEdgeBuffer2 );\n\t\t_quadMesh.render( renderer );\n\n\t\t// 7. Composite\n\n\t\t_quadMesh.material = this._compositeMaterial;\n\t\t_quadMesh.name = 'Outline [ Blur Quarter Resolution ]';\n\t\trenderer.setRenderTarget( this._renderTargetComposite );\n\t\t_quadMesh.render( renderer );\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererAndSceneState( renderer, scene, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup() {\n\n\t\t// prepare mask material\n\n\t\tconst prepareMask = () => {\n\n\t\t\tconst depth = this._depthTextureUniform.sample( screenUV );\n\n\t\t\tlet viewZNode;\n\n\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\tviewZNode = perspectiveDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t} else {\n\n\t\t\t\tviewZNode = orthographicDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t}\n\n\t\t\tconst depthTest = positionView.z.lessThanEqual( viewZNode ).select( 1, 0 );\n\t\t\treturn vec4( 0.0, depthTest, 1.0, 1.0 );\n\n\t\t};\n\n\t\tthis._prepareMaskMaterial.fragmentNode = prepareMask();\n\t\tthis._prepareMaskMaterial.needsUpdate = true;\n\n\t\t// copy material\n\n\t\tthis._materialCopy.fragmentNode = this._maskTextureUniform;\n\t\tthis._materialCopy.needsUpdate = true;\n\n\t\t// edge detection material\n\n\t\tconst edgeDetection = Fn( () => {\n\n\t\t\tconst resolution = textureSize( this._maskTextureDownsSampleUniform );\n\t\t\tconst invSize = vec2( 1 ).div( resolution ).toVar();\n\t\t\tconst uvOffset = vec4( 1.0, 0.0, 0.0, 1.0 ).mul( vec4( invSize, invSize ) );\n\n\t\t\tconst uvNode = uv();\n\t\t\tconst c1 = this._maskTextureDownsSampleUniform.sample( uvNode.add( uvOffset.xy ) ).toVar();\n\t\t\tconst c2 = this._maskTextureDownsSampleUniform.sample( uvNode.sub( uvOffset.xy ) ).toVar();\n\t\t\tconst c3 = this._maskTextureDownsSampleUniform.sample( uvNode.add( uvOffset.yw ) ).toVar();\n\t\t\tconst c4 = this._maskTextureDownsSampleUniform.sample( uvNode.sub( uvOffset.yw ) ).toVar();\n\n\t\t\tconst diff1 = mul( c1.r.sub( c2.r ), 0.5 );\n\t\t\tconst diff2 = mul( c3.r.sub( c4.r ), 0.5 );\n\t\t\tconst d = vec2( diff1, diff2 ).length();\n\t\t\tconst a1 = min( c1.g, c2.g );\n\t\t\tconst a2 = min( c3.g, c4.g );\n\t\t\tconst visibilityFactor = min( a1, a2 );\n\t\t\tconst edgeColor = visibilityFactor.oneMinus().greaterThan( 0.001 ).select( this._visibleEdgeColor, this._hiddenEdgeColor );\n\t\t\treturn vec4( edgeColor, 1 ).mul( d );\n\n\t\t} );\n\n\t\tthis._edgeDetectionMaterial.fragmentNode = edgeDetection();\n\t\tthis._edgeDetectionMaterial.needsUpdate = true;\n\n\t\t// separable blur material\n\n\t\tconst MAX_RADIUS = 4;\n\n\t\tconst gaussianPdf = Fn( ( [ x, sigma ] ) => {\n\n\t\t\treturn float( 0.39894 ).mul( exp( float( - 0.5 ).mul( x ).mul( x ).div( sigma.mul( sigma ) ) ).div( sigma ) );\n\n\t\t} );\n\n\t\tconst separableBlur = Fn( ( [ kernelRadius ] ) => {\n\n\t\t\tconst resolution = textureSize( this._maskTextureDownsSampleUniform );\n\t\t\tconst invSize = vec2( 1 ).div( resolution ).toVar();\n\t\t\tconst uvNode = uv();\n\n\t\t\tconst sigma = kernelRadius.div( 2 ).toVar();\n\t\t\tconst weightSum = gaussianPdf( 0, sigma ).toVar();\n\t\t\tconst diffuseSum = this._blurColorTextureUniform.sample( uvNode ).mul( weightSum ).toVar();\n\t\t\tconst delta = this._blurDirection.mul( invSize ).mul( kernelRadius ).div( MAX_RADIUS ).toVar();\n\n\t\t\tconst uvOffset = delta.toVar();\n\n\t\t\tLoop( { start: int( 1 ), end: int( MAX_RADIUS ), type: 'int', condition: '<=' }, ( { i } ) => {\n\n\t\t\t\tconst x = kernelRadius.mul( float( i ) ).div( MAX_RADIUS );\n\t\t\t\tconst w = gaussianPdf( x, sigma );\n\t\t\t\tconst sample1 = this._blurColorTextureUniform.sample( uvNode.add( uvOffset ) );\n\t\t\t\tconst sample2 = this._blurColorTextureUniform.sample( uvNode.sub( uvOffset ) );\n\n\t\t\t\tdiffuseSum.addAssign( sample1.add( sample2 ).mul( w ) );\n\t\t\t\tweightSum.addAssign( w.mul( 2 ) );\n\t\t\t\tuvOffset.addAssign( delta );\n\n\t\t\t} );\n\n\t\t\treturn diffuseSum.div( weightSum );\n\n\t\t} );\n\n\t\tthis._separableBlurMaterial.fragmentNode = separableBlur( this.edgeThicknessNode );\n\t\tthis._separableBlurMaterial.needsUpdate = true;\n\n\t\tthis._separableBlurMaterial2.fragmentNode = separableBlur( MAX_RADIUS );\n\t\tthis._separableBlurMaterial2.needsUpdate = true;\n\n\t\t// composite material\n\n\t\tconst composite = Fn( () => {\n\n\t\t\tconst edgeValue1 = this._edge1TextureUniform;\n\t\t\tconst edgeValue2 = this._edge2TextureUniform;\n\t\t\tconst maskColor = this._maskTextureUniform;\n\n\t\t\tconst edgeValue = edgeValue1.add( edgeValue2.mul( this.edgeGlowNode ) );\n\n\t\t\treturn maskColor.r.mul( edgeValue );\n\n\t\t} );\n\n\t\tthis._compositeMaterial.fragmentNode = composite();\n\t\tthis._compositeMaterial.needsUpdate = true;\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis.selectedObjects.length = 0;\n\n\t\tthis._renderTargetDepthBuffer.dispose();\n\t\tthis._renderTargetMaskBuffer.dispose();\n\t\tthis._renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis._renderTargetEdgeBuffer1.dispose();\n\t\tthis._renderTargetEdgeBuffer2.dispose();\n\t\tthis._renderTargetBlurBuffer1.dispose();\n\t\tthis._renderTargetBlurBuffer2.dispose();\n\t\tthis._renderTargetComposite.dispose();\n\n\t\tthis._depthMaterial.dispose();\n\t\tthis._prepareMaskMaterial.dispose();\n\t\tthis._materialCopy.dispose();\n\t\tthis._edgeDetectionMaterial.dispose();\n\t\tthis._separableBlurMaterial.dispose();\n\t\tthis._separableBlurMaterial2.dispose();\n\t\tthis._compositeMaterial.dispose();\n\n\t}\n\n\t/**\n\t * Updates the selection cache based on the selected objects.\n\t *\n\t * @private\n\t */\n\t_updateSelectionCache() {\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( ( object ) => {\n\n\t\t\t\tif ( object.isMesh ) this._selectionCache.add( object );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nexport default OutlineNode;\n\n/**\n * TSL function for creating an outline effect around selected objects.\n *\n * @tsl\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - The camera the scene is rendered with.\n * @param {Object} params - The configuration parameters.\n * @param {Array<Object3D>} [params.selectedObjects] - An array of selected objects.\n * @param {Node<float>} [params.edgeThickness=float(1)] - The thickness of the edges.\n * @param {Node<float>} [params.edgeGlow=float(0)] - Can be used for animated glow/pulse effects.\n * @param {number} [params.downSampleRatio=2] - The downsample ratio.\n * @returns {OutlineNode}\n */\nexport const outline = ( scene, camera, params ) => nodeObject( new OutlineNode( scene, camera, params ) );\n"],
  "mappings": "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",
  "names": []
}
