import EventEmitter from 'eventemitter3';

declare abstract class EmptyList {
    protected opaque: any;
}
declare abstract class Cons<T> {
    protected opaque: T;
}
declare type list<T> = Cons<T> | EmptyList;

declare abstract class props {
    protected opaque: any;
}
declare type t = {
    readonly symbol: string;
    readonly hash: number;
    readonly kind: string;
    readonly props: props;
    readonly outputChannel: number;
    readonly children: list<t>;
};

declare type ElemNode = t | number;

declare function resolve(n: ElemNode): t;
declare function isNode(n: unknown): n is t;
declare function createNode(kind: string, props: any, children: Array<ElemNode>): t;
declare function unpack(node: t, numChannels: number): Array<t>;

declare abstract class RenderDelegate_t {
    protected opaque: any;
}
declare const renderWithDelegate: <T1, T2>(delegate: RenderDelegate_t, graphs: t[], rootFadeInMs: T1, rootFadeOutMs: T2) => void;

declare function constant(props: {
    key?: string;
    value: number;
}): t;

declare function identity(props: {
    key?: string;
    channel?: number;
}, x?: ElemNode): t;

declare function sample(props: {
    key?: string;
    path: string;
    channels: number;
    mode?: string;
    startOffset?: number;
    stopOffset?: number;
    playbackRate?: number;
}, gate: ElemNode): Array<t>;
declare function sampleseq(props: {
    key?: string;
    seq: Array<{
        value: number;
        time: number;
    }>;
    duration: number;
    path: string;
    channels: number;
}, time: ElemNode): Array<t>;
declare function sampleseq2(props: {
    key?: string;
    seq: Array<{
        value: number;
        time: number;
    }>;
    duration: number;
    path: string;
    stretch?: number;
    shift?: number;
    channels: number;
}, time: ElemNode): Array<t>;
declare function table(props: {
    key?: string;
    path: string;
    channels: number;
}, t: ElemNode): Array<t>;
declare function capture(props: {
    name?: string;
    channels: number;
}, g: ElemNode, ...args: Array<t>): Array<t>;

declare const mc_sample: typeof sample;
declare const mc_sampleseq: typeof sampleseq;
declare const mc_sampleseq2: typeof sampleseq2;
declare const mc_table: typeof table;
declare const mc_capture: typeof capture;
declare namespace mc {
  export {
    mc_sample as sample,
    mc_sampleseq as sampleseq,
    mc_sampleseq2 as sampleseq2,
    mc_table as table,
    mc_capture as capture,
  };
}

declare type EventTypes = {
    capture: (data: {
        source?: string;
        data: Float32Array;
    }) => void;
    error: (error: Error) => void;
    fft: (data: {
        source?: string;
        data: {
            real: Float32Array;
            imag: Float32Array;
        };
    }) => void;
    load: () => void;
    meter: (data: {
        source?: string;
        min: number;
        max: number;
    }) => void;
    scope: (data: {
        source?: string;
        data: Float32Array[];
    }) => void;
    snapshot: (data: {
        source?: string;
        data: number;
    }) => void;
};
declare class export_default extends EventEmitter<EventTypes> {
    constructor();
}

declare const stdlib: {
    mc: typeof mc;
    const: typeof constant;
    in: typeof identity;
    ms2samps(t: ElemNode): t;
    tau2pole(t: ElemNode): t;
    db2gain(db: ElemNode): t;
    gain2db(gain: ElemNode): t;
    select(g: ElemNode, a: ElemNode, b: ElemNode): t;
    hann(t: ElemNode): t;
    train(rate: ElemNode): t;
    cycle(rate: ElemNode): t;
    saw(rate: ElemNode): t;
    square(rate: ElemNode): t;
    triangle(rate: ElemNode): t;
    blepsaw(rate: ElemNode): t;
    blepsquare(rate: ElemNode): t;
    bleptriangle(rate: ElemNode): t;
    noise(props?: {
        key?: string;
        seed?: number;
    }): t;
    pinknoise(props?: {
        key?: string;
        seed?: number;
    }): t;
    identity(props: {
        key?: string;
        channel?: number;
    }, x?: ElemNode): t;
    sin(x: ElemNode): t;
    cos(x: ElemNode): t;
    tan(x: ElemNode): t;
    tanh(x: ElemNode): t;
    asinh(x: ElemNode): t;
    ln(x: ElemNode): t;
    log(x: ElemNode): t;
    log2(x: ElemNode): t;
    ceil(x: ElemNode): t;
    floor(x: ElemNode): t;
    round(x: ElemNode): t;
    sqrt(x: ElemNode): t;
    exp(x: ElemNode): t;
    abs(x: ElemNode): t;
    le(a: ElemNode, b: ElemNode): t;
    leq(a: ElemNode, b: ElemNode): t;
    ge(a: ElemNode, b: ElemNode): t;
    geq(a: ElemNode, b: ElemNode): t;
    pow(a: ElemNode, b: ElemNode): t;
    eq(a: ElemNode, b: ElemNode): t;
    and(a: ElemNode, b: ElemNode): t;
    or(a: ElemNode, b: ElemNode): t;
    add(...args: ElemNode[]): t;
    sub(...args: ElemNode[]): t;
    mul(...args: ElemNode[]): t;
    div(...args: ElemNode[]): t;
    mod(...args: ElemNode[]): t;
    min(...args: ElemNode[]): t;
    max(...args: ElemNode[]): t;
    smooth(p: ElemNode, x: ElemNode): t;
    sm(x: ElemNode): t;
    zero(b0: ElemNode, b1: ElemNode, x: ElemNode): t;
    dcblock(x: ElemNode): t;
    df11(b0: ElemNode, b1: ElemNode, a1: ElemNode, x: ElemNode): t;
    lowpass(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    highpass(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    bandpass(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    notch(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    allpass(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    peak(fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    lowshelf(fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    highshelf(fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    pink(x: ElemNode): t;
    adsr(attackSec: ElemNode, decaySec: ElemNode, sustain: ElemNode, releaseSec: ElemNode, gate: ElemNode): t;
    compress(attackMs: ElemNode, releaseMs: ElemNode, threshold: ElemNode, ratio: ElemNode, sidechain: ElemNode, xn: ElemNode): t;
    skcompress(attackMs: ElemNode, releaseMs: ElemNode, threshold: ElemNode, ratio: ElemNode, kneeWidth: ElemNode, sidechain: ElemNode, xn: ElemNode): t;
    constant(props: {
        key?: string;
        value: number;
    }): t;
    sr(): t;
    time(): t;
    counter(gate: ElemNode): t;
    accum(xn: ElemNode, reset: ElemNode): t;
    phasor(rate: ElemNode): t;
    syncphasor(rate: ElemNode, reset: ElemNode): t;
    latch(t: ElemNode, x: ElemNode): t;
    maxhold(props: {
        key?: string;
        hold?: number;
    }, x: ElemNode, reset: ElemNode): t;
    once(props: {
        key?: string;
        arm?: boolean;
    }, x: ElemNode): t;
    rand(props?: {
        key?: string;
        seed?: number;
    }): t;
    metro(props?: {
        key?: string;
        name?: string;
        interval?: number;
    }): t;
    sample(props: {
        key?: string;
        path: string;
        mode?: string;
        startOffset?: number;
        stopOffset?: number;
    }, trigger: ElemNode, rate: ElemNode): t;
    table(props: {
        key?: string;
        path: string;
    }, t: ElemNode): t;
    convolve(props: {
        key?: string;
        path: string;
    }, x: ElemNode): t;
    seq(props: {
        key?: string;
        seq: number[];
        offset?: number;
        hold?: boolean;
        loop?: boolean;
    }, trigger: ElemNode, reset: ElemNode): t;
    seq2(props: {
        key?: string;
        seq: number[];
        offset?: number;
        hold?: boolean;
        loop?: boolean;
    }, trigger: ElemNode, reset: ElemNode): t;
    sparseq(props: {
        key?: string;
        seq: {
            value: number;
            tickTime: number;
        }[];
        offset?: number;
        loop?: boolean | number[];
        interpolate?: number;
        tickInterval?: number;
    }, trigger: ElemNode, reset: ElemNode): t;
    sparseq2(props: {
        key?: string;
        seq: {
            value: number;
            time: number;
        }[];
    }, time: ElemNode): t;
    sampleseq(props: {
        key?: string;
        path: string;
        seq: {
            value: number;
            time: number;
        }[];
        duration: number;
    }, time: ElemNode): t;
    sampleseq2(props: {
        key?: string;
        path: string;
        seq: {
            value: number;
            time: number;
        }[];
        duration: number;
        stretch?: number;
        shift?: number;
    }, time: ElemNode): t;
    pole(p: ElemNode, x: ElemNode): t;
    env(atkPole: ElemNode, relPole: ElemNode, x: ElemNode): t;
    z(x: ElemNode): t;
    delay(props: {
        key?: string;
        size: number;
    }, len: ElemNode, fb: ElemNode, x: ElemNode): t;
    sdelay(props: {
        key?: string;
        size: number;
    }, x: ElemNode): t;
    prewarp(fc: ElemNode): t;
    mm1p(props: {
        key?: string;
        mode?: string;
    }, fc: ElemNode, x: ElemNode): t;
    svf(props: {
        key?: string;
        mode?: string;
    }, fc: ElemNode, q: ElemNode, x: ElemNode): t;
    svfshelf(props: {
        key?: string;
        mode?: string;
    }, fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    biquad(b0: ElemNode, b1: ElemNode, b2: ElemNode, a1: ElemNode, a2: ElemNode, x: ElemNode): t;
    tapIn(props: {
        key?: string;
        name: string;
    }): t;
    tapOut(props: {
        key?: string;
        name: string;
    }, x: ElemNode): t;
    meter(props: {
        key?: string;
        name?: string;
    }, x: ElemNode): t;
    snapshot(props: {
        key?: string;
        name?: string;
    }, trigger: ElemNode, x: ElemNode): t;
    scope(props: {
        key?: string;
        name?: string;
        size?: number;
        channels?: number;
    }, ...args: ElemNode[]): t;
    fft(props: {
        key?: string;
        name?: string;
        size?: number;
    }, x: ElemNode): t;
    capture(props: {
        key?: string;
    }, g: ElemNode, x: ElemNode): t;
};
declare class Delegate {
    nodesAdded: number;
    nodesRemoved: number;
    edgesAdded: number;
    propsWritten: number;
    nodeMap: Map<number, any>;
    private currentActiveRoots;
    private batch;
    constructor();
    clear(): void;
    getNodeMap(): Map<number, any>;
    createNode(hash: any, type: any): void;
    appendChild(parentHash: any, childHash: any, childOutputChannel: any): void;
    setProperty(hash: any, key: any, value: any): void;
    activateRoots(roots: any): void;
    commitUpdates(): void;
    getPackedInstructions(): any[];
}
declare class Renderer {
    private _delegate;
    private _sendMessage;
    private _nextRefId;
    constructor(sendMessage: any);
    createRef(kind: any, props: any, children: any): (t | ((newProps: any) => Promise<any>))[];
    render(...args: any[]): Promise<{
        result: any;
        nodesAdded: number;
        edgesAdded: number;
        propsWritten: number;
        elapsedTimeMs: number;
    }>;
    renderWithOptions(options: {
        rootFadeInMs: number;
        rootFadeOutMs: number;
    }, ...args: any[]): Promise<{
        result: any;
        nodesAdded: number;
        edgesAdded: number;
        propsWritten: number;
        elapsedTimeMs: number;
    }>;
    prune(nodeIds: any): void;
}

export { Delegate, ElemNode, export_default as EventEmitter, t as NodeRepr_t, Renderer, createNode, stdlib as el, isNode, renderWithDelegate, resolve, stdlib, unpack };
