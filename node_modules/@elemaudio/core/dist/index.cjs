var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target, mod2));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// index.ts
var core_exports2 = {};
__export(core_exports2, {
  Delegate: () => Delegate,
  EventEmitter: () => Events_default,
  Renderer: () => Renderer,
  createNode: () => createNode,
  el: () => stdlib,
  isNode: () => isNode3,
  renderWithDelegate: () => renderWithDelegate2,
  resolve: () => resolve,
  stdlib: () => stdlib,
  unpack: () => unpack
});
module.exports = __toCommonJS(core_exports2);

// node_modules/rescript/lib/es6/curry.js
var curry_exports = {};
__export(curry_exports, {
  _1: () => _1,
  _2: () => _2,
  _3: () => _3,
  _4: () => _4,
  _5: () => _5,
  _6: () => _6,
  _7: () => _7,
  _8: () => _8,
  __1: () => __1,
  __2: () => __2,
  __3: () => __3,
  __4: () => __4,
  __5: () => __5,
  __6: () => __6,
  __7: () => __7,
  __8: () => __8,
  app: () => app
});

// node_modules/rescript/lib/es6/caml_array.js
function sub(x, offset, len) {
  var result = new Array(len);
  var j = 0;
  var i = offset;
  while (j < len) {
    result[j] = x[i];
    j = j + 1 | 0;
    i = i + 1 | 0;
  }
  ;
  return result;
}

// node_modules/rescript/lib/es6/curry.js
function app(_f, _args) {
  while (true) {
    var args = _args;
    var f = _f;
    var init_arity = f.length;
    var arity = init_arity === 0 ? 1 : init_arity;
    var len = args.length;
    var d = arity - len | 0;
    if (d === 0) {
      return f.apply(null, args);
    }
    if (d >= 0) {
      return function(f2, args2) {
        return function(x) {
          return app(f2, args2.concat([x]));
        };
      }(f, args);
    }
    _args = sub(args, arity, -d | 0);
    _f = f.apply(null, sub(args, 0, arity));
    continue;
  }
  ;
}
function _1(o, a0) {
  var arity = o.length;
  if (arity === 1) {
    return o(a0);
  } else {
    switch (arity) {
      case 1:
        return o(a0);
      case 2:
        return function(param) {
          return o(a0, param);
        };
      case 3:
        return function(param, param$1) {
          return o(a0, param, param$1);
        };
      case 4:
        return function(param, param$1, param$2) {
          return o(a0, param, param$1, param$2);
        };
      case 5:
        return function(param, param$1, param$2, param$3) {
          return o(a0, param, param$1, param$2, param$3);
        };
      case 6:
        return function(param, param$1, param$2, param$3, param$4) {
          return o(a0, param, param$1, param$2, param$3, param$4);
        };
      case 7:
        return function(param, param$1, param$2, param$3, param$4, param$5) {
          return o(a0, param, param$1, param$2, param$3, param$4, param$5);
        };
      default:
        return app(o, [a0]);
    }
  }
}
function __1(o) {
  var arity = o.length;
  if (arity === 1) {
    return o;
  } else {
    return function(a0) {
      return _1(o, a0);
    };
  }
}
function _2(o, a0, a1) {
  var arity = o.length;
  if (arity === 2) {
    return o(a0, a1);
  } else {
    switch (arity) {
      case 1:
        return app(o(a0), [a1]);
      case 2:
        return o(a0, a1);
      case 3:
        return function(param) {
          return o(a0, a1, param);
        };
      case 4:
        return function(param, param$1) {
          return o(a0, a1, param, param$1);
        };
      case 5:
        return function(param, param$1, param$2) {
          return o(a0, a1, param, param$1, param$2);
        };
      case 6:
        return function(param, param$1, param$2, param$3) {
          return o(a0, a1, param, param$1, param$2, param$3);
        };
      case 7:
        return function(param, param$1, param$2, param$3, param$4) {
          return o(a0, a1, param, param$1, param$2, param$3, param$4);
        };
      default:
        return app(o, [
          a0,
          a1
        ]);
    }
  }
}
function __2(o) {
  var arity = o.length;
  if (arity === 2) {
    return o;
  } else {
    return function(a0, a1) {
      return _2(o, a0, a1);
    };
  }
}
function _3(o, a0, a1, a2) {
  var arity = o.length;
  if (arity === 3) {
    return o(a0, a1, a2);
  } else {
    switch (arity) {
      case 1:
        return app(o(a0), [
          a1,
          a2
        ]);
      case 2:
        return app(o(a0, a1), [a2]);
      case 3:
        return o(a0, a1, a2);
      case 4:
        return function(param) {
          return o(a0, a1, a2, param);
        };
      case 5:
        return function(param, param$1) {
          return o(a0, a1, a2, param, param$1);
        };
      case 6:
        return function(param, param$1, param$2) {
          return o(a0, a1, a2, param, param$1, param$2);
        };
      case 7:
        return function(param, param$1, param$2, param$3) {
          return o(a0, a1, a2, param, param$1, param$2, param$3);
        };
      default:
        return app(o, [
          a0,
          a1,
          a2
        ]);
    }
  }
}
function __3(o) {
  var arity = o.length;
  if (arity === 3) {
    return o;
  } else {
    return function(a0, a1, a2) {
      return _3(o, a0, a1, a2);
    };
  }
}
function _4(o, a0, a1, a2, a3) {
  var arity = o.length;
  if (arity === 4) {
    return o(a0, a1, a2, a3);
  } else {
    switch (arity) {
      case 1:
        return app(o(a0), [
          a1,
          a2,
          a3
        ]);
      case 2:
        return app(o(a0, a1), [
          a2,
          a3
        ]);
      case 3:
        return app(o(a0, a1, a2), [a3]);
      case 4:
        return o(a0, a1, a2, a3);
      case 5:
        return function(param) {
          return o(a0, a1, a2, a3, param);
        };
      case 6:
        return function(param, param$1) {
          return o(a0, a1, a2, a3, param, param$1);
        };
      case 7:
        return function(param, param$1, param$2) {
          return o(a0, a1, a2, a3, param, param$1, param$2);
        };
      default:
        return app(o, [
          a0,
          a1,
          a2,
          a3
        ]);
    }
  }
}
function __4(o) {
  var arity = o.length;
  if (arity === 4) {
    return o;
  } else {
    return function(a0, a1, a2, a3) {
      return _4(o, a0, a1, a2, a3);
    };
  }
}
function _5(o, a0, a1, a2, a3, a4) {
  var arity = o.length;
  if (arity === 5) {
    return o(a0, a1, a2, a3, a4);
  } else {
    switch (arity) {
      case 1:
        return app(o(a0), [
          a1,
          a2,
          a3,
          a4
        ]);
      case 2:
        return app(o(a0, a1), [
          a2,
          a3,
          a4
        ]);
      case 3:
        return app(o(a0, a1, a2), [
          a3,
          a4
        ]);
      case 4:
        return app(o(a0, a1, a2, a3), [a4]);
      case 5:
        return o(a0, a1, a2, a3, a4);
      case 6:
        return function(param) {
          return o(a0, a1, a2, a3, a4, param);
        };
      case 7:
        return function(param, param$1) {
          return o(a0, a1, a2, a3, a4, param, param$1);
        };
      default:
        return app(o, [
          a0,
          a1,
          a2,
          a3,
          a4
        ]);
    }
  }
}
function __5(o) {
  var arity = o.length;
  if (arity === 5) {
    return o;
  } else {
    return function(a0, a1, a2, a3, a4) {
      return _5(o, a0, a1, a2, a3, a4);
    };
  }
}
function _6(o, a0, a1, a2, a3, a4, a5) {
  var arity = o.length;
  if (arity === 6) {
    return o(a0, a1, a2, a3, a4, a5);
  } else {
    switch (arity) {
      case 1:
        return app(o(a0), [
          a1,
          a2,
          a3,
          a4,
          a5
        ]);
      case 2:
        return app(o(a0, a1), [
          a2,
          a3,
          a4,
          a5
        ]);
      case 3:
        return app(o(a0, a1, a2), [
          a3,
          a4,
          a5
        ]);
      case 4:
        return app(o(a0, a1, a2, a3), [
          a4,
          a5
        ]);
      case 5:
        return app(o(a0, a1, a2, a3, a4), [a5]);
      case 6:
        return o(a0, a1, a2, a3, a4, a5);
      case 7:
        return function(param) {
          return o(a0, a1, a2, a3, a4, a5, param);
        };
      default:
        return app(o, [
          a0,
          a1,
          a2,
          a3,
          a4,
          a5
        ]);
    }
  }
}
function __6(o) {
  var arity = o.length;
  if (arity === 6) {
    return o;
  } else {
    return function(a0, a1, a2, a3, a4, a5) {
      return _6(o, a0, a1, a2, a3, a4, a5);
    };
  }
}
function _7(o, a0, a1, a2, a3, a4, a5, a6) {
  var arity = o.length;
  if (arity === 7) {
    return o(a0, a1, a2, a3, a4, a5, a6);
  } else {
    switch (arity) {
      case 1:
        return app(o(a0), [
          a1,
          a2,
          a3,
          a4,
          a5,
          a6
        ]);
      case 2:
        return app(o(a0, a1), [
          a2,
          a3,
          a4,
          a5,
          a6
        ]);
      case 3:
        return app(o(a0, a1, a2), [
          a3,
          a4,
          a5,
          a6
        ]);
      case 4:
        return app(o(a0, a1, a2, a3), [
          a4,
          a5,
          a6
        ]);
      case 5:
        return app(o(a0, a1, a2, a3, a4), [
          a5,
          a6
        ]);
      case 6:
        return app(o(a0, a1, a2, a3, a4, a5), [a6]);
      case 7:
        return o(a0, a1, a2, a3, a4, a5, a6);
      default:
        return app(o, [
          a0,
          a1,
          a2,
          a3,
          a4,
          a5,
          a6
        ]);
    }
  }
}
function __7(o) {
  var arity = o.length;
  if (arity === 7) {
    return o;
  } else {
    return function(a0, a1, a2, a3, a4, a5, a6) {
      return _7(o, a0, a1, a2, a3, a4, a5, a6);
    };
  }
}
function _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {
  var arity = o.length;
  if (arity === 8) {
    return o(a0, a1, a2, a3, a4, a5, a6, a7);
  } else {
    switch (arity) {
      case 1:
        return app(o(a0), [
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7
        ]);
      case 2:
        return app(o(a0, a1), [
          a2,
          a3,
          a4,
          a5,
          a6,
          a7
        ]);
      case 3:
        return app(o(a0, a1, a2), [
          a3,
          a4,
          a5,
          a6,
          a7
        ]);
      case 4:
        return app(o(a0, a1, a2, a3), [
          a4,
          a5,
          a6,
          a7
        ]);
      case 5:
        return app(o(a0, a1, a2, a3, a4), [
          a5,
          a6,
          a7
        ]);
      case 6:
        return app(o(a0, a1, a2, a3, a4, a5), [
          a6,
          a7
        ]);
      case 7:
        return app(o(a0, a1, a2, a3, a4, a5, a6), [a7]);
      default:
        return app(o, [
          a0,
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7
        ]);
    }
  }
}
function __8(o) {
  var arity = o.length;
  if (arity === 8) {
    return o;
  } else {
    return function(a0, a1, a2, a3, a4, a5, a6, a7) {
      return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);
    };
  }
}

// src/Reconciler.bs.js
var Reconciler_bs_exports = {};
__export(Reconciler_bs_exports, {
  $$Map: () => $$Map,
  $$Set: () => $$Set,
  RenderDelegate: () => RenderDelegate,
  mount: () => mount,
  renderWithDelegate: () => renderWithDelegate,
  visit: () => visit
});

// src/NodeRepr.bs.js
var NodeRepr_bs_exports = {};
__export(NodeRepr_bs_exports, {
  create: () => create,
  isNode: () => isNode,
  shallowCopy: () => shallowCopy,
  symbol: () => symbol
});

// node_modules/rescript/lib/es6/js_types.js
function classify(x) {
  var ty = typeof x;
  if (ty === "undefined") {
    return 3;
  } else if (x === null) {
    return 2;
  } else if (ty === "number") {
    return {
      TAG: 0,
      _0: x
    };
  } else if (ty === "bigint") {
    return {
      TAG: 5,
      _0: x
    };
  } else if (ty === "string") {
    return {
      TAG: 1,
      _0: x
    };
  } else if (ty === "boolean") {
    if (x === true) {
      return 1;
    } else {
      return 0;
    }
  } else if (ty === "symbol") {
    return {
      TAG: 4,
      _0: x
    };
  } else if (ty === "function") {
    return {
      TAG: 2,
      _0: x
    };
  } else {
    return {
      TAG: 3,
      _0: x
    };
  }
}
function test(x, v) {
  switch (v) {
    case 0:
      return typeof x === "undefined";
    case 1:
      return x === null;
    case 2:
      return typeof x === "boolean";
    case 3:
      return typeof x === "number";
    case 4:
      return typeof x === "string";
    case 5:
      return typeof x === "function";
    case 6:
      return typeof x === "object";
    case 7:
      return typeof x === "symbol";
    case 8:
      return typeof x === "bigint";
  }
}

// node_modules/rescript/lib/es6/caml_option.js
function some(x) {
  if (x === void 0) {
    return {
      BS_PRIVATE_NESTED_SOME_NONE: 0
    };
  } else if (x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== void 0) {
    return {
      BS_PRIVATE_NESTED_SOME_NONE: x.BS_PRIVATE_NESTED_SOME_NONE + 1 | 0
    };
  } else {
    return x;
  }
}
function valFromOption(x) {
  if (!(x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== void 0)) {
    return x;
  }
  var depth = x.BS_PRIVATE_NESTED_SOME_NONE;
  if (depth === 0) {
    return;
  } else {
    return {
      BS_PRIVATE_NESTED_SOME_NONE: depth - 1 | 0
    };
  }
}

// node_modules/rescript/lib/es6/belt_List.js
function copyAuxCont(_cellX, _prec) {
  while (true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return prec;
    }
    var next = {
      hd: cellX.hd,
      tl: 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue;
  }
  ;
}
function copyAuxWithMap(_cellX, _prec, f) {
  while (true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return;
    }
    var next = {
      hd: f(cellX.hd),
      tl: 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue;
  }
  ;
}
function copyAuxWithMapI(f, _i, _cellX, _prec) {
  while (true) {
    var prec = _prec;
    var cellX = _cellX;
    var i = _i;
    if (!cellX) {
      return;
    }
    var next = {
      hd: f(i, cellX.hd),
      tl: 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function concat(xs, ys) {
  if (!xs) {
    return ys;
  }
  var cell = {
    hd: xs.hd,
    tl: 0
  };
  copyAuxCont(xs.tl, cell).tl = ys;
  return cell;
}
function mapU(xs, f) {
  if (!xs) {
    return 0;
  }
  var cell = {
    hd: f(xs.hd),
    tl: 0
  };
  copyAuxWithMap(xs.tl, cell, f);
  return cell;
}
function map(xs, f) {
  return mapU(xs, __1(f));
}
function mapWithIndexU(xs, f) {
  if (!xs) {
    return 0;
  }
  var cell = {
    hd: f(0, xs.hd),
    tl: 0
  };
  copyAuxWithMapI(f, 1, xs.tl, cell);
  return cell;
}
function mapWithIndex(xs, f) {
  return mapWithIndexU(xs, __2(f));
}
function length(xs) {
  var _x = xs;
  var _acc = 0;
  while (true) {
    var acc = _acc;
    var x = _x;
    if (!x) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _x = x.tl;
    continue;
  }
  ;
}
function fillAux(arr, _i, _x) {
  while (true) {
    var x = _x;
    var i = _i;
    if (!x) {
      return;
    }
    arr[i] = x.hd;
    _x = x.tl;
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function fromArray(a) {
  var _i = a.length - 1 | 0;
  var _res = 0;
  while (true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue;
  }
  ;
}
function toArray(x) {
  var len = length(x);
  var arr = new Array(len);
  fillAux(arr, 0, x);
  return arr;
}
function forEachU(_xs, f) {
  while (true) {
    var xs = _xs;
    if (!xs) {
      return;
    }
    f(xs.hd);
    _xs = xs.tl;
    continue;
  }
  ;
}
function forEach(xs, f) {
  forEachU(xs, __1(f));
}
function reduceU(_l, _accu, f) {
  while (true) {
    var accu = _accu;
    var l = _l;
    if (!l) {
      return accu;
    }
    _accu = f(accu, l.hd);
    _l = l.tl;
    continue;
  }
  ;
}

// src/Hash.ts
var import_shallowequal = __toESM(require("shallowequal"), 1);
function updateNodeProps(renderer, hash, prevProps, nextProps) {
  for (let key in nextProps) {
    if (nextProps.hasOwnProperty(key)) {
      const value = nextProps[key];
      const shouldUpdate = !prevProps.hasOwnProperty(key) || !(0, import_shallowequal.default)(prevProps[key], value);
      if (shouldUpdate) {
        const seemsInvalid = typeof value === "undefined" || value === null || typeof value === "number" && isNaN(value) || typeof value === "number" && !isFinite(value);
        if (seemsInvalid) {
          console.warn(`Warning: applying a potentially erroneous property value. ${key}: ${value}`);
        }
        renderer.setProperty(hash, key, value);
        prevProps[key] = value;
      }
    }
  }
}

// node_modules/rescript/lib/es6/js_dict.js
function get(dict, k) {
  if (k in dict) {
    return some(dict[k]);
  }
}

// node_modules/rescript/lib/es6/js_option.js
function getExn(x) {
  if (x !== void 0) {
    return valFromOption(x);
  }
  throw new Error("getExn");
}

// src/HashUtils.bs.js
function updateNodeProps2(prim0, prim1, prim2, prim3) {
  updateNodeProps(prim0, prim1, prim2, prim3);
}
function mixNumber(seed, n) {
  return Math.imul(seed ^ n, 16777619);
}
function hashString(seed, s) {
  var r = seed;
  for (var i = 0, i_finish = s.length; i <= i_finish; ++i) {
    r = mixNumber(r, s.charCodeAt(i) | 0);
  }
  return r;
}
function hashNode(kind, props, children) {
  var r = hashString(-2128831035, kind);
  var k = get(props, "key");
  var r2 = k !== void 0 && test(k, 4) ? hashString(r, k) : hashString(r, getExn(JSON.stringify(props)));
  return reduceU(children, r2, mixNumber) & 2147483647;
}

// src/NodeRepr.bs.js
var symbol = "__ELEM_NODE__";
function create(kind, props, children) {
  var childrenList = fromArray(children);
  return {
    symbol,
    hash: hashNode(kind, props, map(childrenList, function(n) {
      return mixNumber(n.hash, n.outputChannel);
    })),
    kind,
    props,
    outputChannel: 0,
    children: childrenList
  };
}
function isNode(a) {
  var match = classify(a);
  if (typeof match === "number") {
    return false;
  }
  if (match.TAG !== 3) {
    return false;
  }
  var s = classify(a.symbol);
  if (typeof s === "number" || s.TAG !== 1) {
    return false;
  } else {
    return s._0 === symbol;
  }
}
function shallowCopy(node) {
  return {
    symbol: node.symbol,
    hash: node.hash,
    kind: node.kind,
    props: Object.assign({}, node.props),
    outputChannel: node.outputChannel,
    generation: {
      contents: 0
    }
  };
}

// src/Reconciler.bs.js
function valuesArray(m) {
  return Array.from(m.values());
}
var $$Map = {
  valuesArray
};
var $$Set = {};
var RenderDelegate = {};
function mount(delegate, node) {
  var nodeMap = delegate.getNodeMap();
  if (nodeMap.has(node.hash)) {
    var existing = nodeMap.get(node.hash);
    return updateNodeProps2(delegate, existing.hash, existing.props, node.props);
  }
  delegate.createNode(node.hash, node.kind);
  updateNodeProps2(delegate, node.hash, {}, node.props);
  forEach(node.children, function(child) {
    delegate.appendChild(node.hash, child.hash, child.outputChannel);
  });
  nodeMap.set(node.hash, shallowCopy(node));
}
function visit(delegate, visitSet, _ns) {
  while (true) {
    var ns = _ns;
    var markVisited = function(n2) {
      visitSet.add(n2.hash);
    };
    if (!ns) {
      return;
    }
    var rest = ns.tl;
    var n = ns.hd;
    if (visitSet.has(n.hash)) {
      _ns = rest;
      continue;
    }
    markVisited(n);
    mount(delegate, n);
    _ns = concat(n.children, rest);
    continue;
  }
  ;
}
function renderWithDelegate(delegate, graphs, rootFadeInMs, rootFadeOutMs) {
  var visitSet = /* @__PURE__ */ new Set();
  var roots = mapWithIndex(fromArray(graphs), function(i, g) {
    return create("root", {
      channel: i,
      fadeInMs: rootFadeInMs,
      fadeOutMs: rootFadeOutMs
    }, [g]);
  });
  visit(delegate, visitSet, roots);
  delegate.activateRoots(toArray(map(roots, function(r) {
    return r.hash;
  })));
  delegate.commitUpdates();
}

// src/Reconciler.gen.ts
var Curry = curry_exports;
var ReconcilerBS = Reconciler_bs_exports;
var renderWithDelegate2 = function(Arg1, Arg2, Arg3, Arg4) {
  const result = Curry._4(ReconcilerBS.renderWithDelegate, Arg1, Arg2, Arg3, Arg4);
  return result;
};

// src/NodeRepr.gen.ts
var Curry2 = curry_exports;
var NodeReprBS = NodeRepr_bs_exports;
var create2 = function(Arg1, Arg2, Arg3) {
  const result = Curry2._3(NodeReprBS.create, Arg1, Arg2, Arg3);
  return result;
};
var isNode2 = NodeReprBS.isNode;
var shallowCopy2 = NodeReprBS.shallowCopy;

// nodeUtils.ts
var import_invariant = __toESM(require("invariant"), 1);
function resolve(n) {
  if (typeof n === "number")
    return create2("const", { value: n }, []);
  (0, import_invariant.default)(isNode3(n), `Whoops, expecting a Node type here! Got: ${typeof n}`);
  return n;
}
function isNode3(n) {
  return isNode2(n);
}
function createNode(kind, props, children) {
  return create2(kind, props, children.map(resolve));
}
function unpack(node, numChannels) {
  return Array.from({ length: numChannels }, (v, i) => {
    return __spreadProps(__spreadValues({}, node), {
      outputChannel: i
    });
  });
}

// lib/core.ts
var core_exports = {};
__export(core_exports, {
  accum: () => accum,
  biquad: () => biquad,
  capture: () => capture,
  constant: () => constant,
  convolve: () => convolve,
  counter: () => counter,
  delay: () => delay,
  env: () => env,
  fft: () => fft,
  latch: () => latch,
  maxhold: () => maxhold,
  meter: () => meter,
  metro: () => metro,
  mm1p: () => mm1p,
  once: () => once,
  phasor: () => phasor,
  pole: () => pole,
  prewarp: () => prewarp,
  rand: () => rand,
  sample: () => sample,
  sampleseq: () => sampleseq,
  sampleseq2: () => sampleseq2,
  scope: () => scope,
  sdelay: () => sdelay,
  seq: () => seq,
  seq2: () => seq2,
  snapshot: () => snapshot,
  sparseq: () => sparseq,
  sparseq2: () => sparseq2,
  sr: () => sr,
  svf: () => svf,
  svfshelf: () => svfshelf,
  syncphasor: () => syncphasor,
  table: () => table,
  tapIn: () => tapIn,
  tapOut: () => tapOut,
  time: () => time,
  z: () => z
});
function constant(props) {
  return createNode("const", props, []);
}
function sr() {
  return createNode("sr", {}, []);
}
function time() {
  return createNode("time", {}, []);
}
function counter(gate) {
  return createNode("counter", {}, [resolve(gate)]);
}
function accum(xn, reset) {
  return createNode("accum", {}, [resolve(xn), resolve(reset)]);
}
function phasor(rate) {
  return createNode("phasor", {}, [resolve(rate)]);
}
function syncphasor(rate, reset) {
  return createNode("sphasor", {}, [resolve(rate), resolve(reset)]);
}
function latch(t, x) {
  return createNode("latch", {}, [resolve(t), resolve(x)]);
}
function maxhold(props, x, reset) {
  return createNode("maxhold", props, [resolve(x), resolve(reset)]);
}
function once(props, x) {
  return createNode("once", props, [resolve(x)]);
}
function rand(props) {
  return createNode("rand", props || {}, []);
}
function metro(props) {
  return createNode("metro", props || {}, []);
}
function sample(props, trigger, rate) {
  return createNode("sample", props, [resolve(trigger), resolve(rate)]);
}
function table(props, t) {
  return createNode("table", props, [resolve(t)]);
}
function convolve(props, x) {
  return createNode("convolve", props, [resolve(x)]);
}
function seq(props, trigger, reset) {
  return createNode("seq", props, [resolve(trigger), resolve(reset)]);
}
function seq2(props, trigger, reset) {
  return createNode("seq2", props, [resolve(trigger), resolve(reset)]);
}
function sparseq(props, trigger, reset) {
  return createNode("sparseq", props, [resolve(trigger), resolve(reset)]);
}
function sparseq2(props, time2) {
  return createNode("sparseq2", props, [resolve(time2)]);
}
function sampleseq(props, time2) {
  return createNode("sampleseq", props, [resolve(time2)]);
}
function sampleseq2(props, time2) {
  return createNode("sampleseq2", props, [resolve(time2)]);
}
function pole(p, x) {
  return createNode("pole", {}, [resolve(p), resolve(x)]);
}
function env(atkPole, relPole, x) {
  return createNode("env", {}, [
    resolve(atkPole),
    resolve(relPole),
    resolve(x)
  ]);
}
function z(x) {
  return createNode("z", {}, [resolve(x)]);
}
function delay(props, len, fb, x) {
  return createNode("delay", props, [resolve(len), resolve(fb), resolve(x)]);
}
function sdelay(props, x) {
  return createNode("sdelay", props, [resolve(x)]);
}
function prewarp(fc) {
  return createNode("prewarp", {}, [resolve(fc)]);
}
function mm1p(props, fc, x) {
  return createNode("mm1p", props, [resolve(fc), resolve(x)]);
}
function svf(props, fc, q, x) {
  return createNode("svf", props, [resolve(fc), resolve(q), resolve(x)]);
}
function svfshelf(props, fc, q, gainDecibels, x) {
  return createNode("svfshelf", props, [
    resolve(fc),
    resolve(q),
    resolve(gainDecibels),
    resolve(x)
  ]);
}
function biquad(b0, b1, b2, a1, a2, x) {
  return createNode("biquad", {}, [
    resolve(b0),
    resolve(b1),
    resolve(b2),
    resolve(a1),
    resolve(a2),
    resolve(x)
  ]);
}
function tapIn(props) {
  return createNode("tapIn", props, []);
}
function tapOut(props, x) {
  return createNode("tapOut", props, [resolve(x)]);
}
function meter(props, x) {
  return createNode("meter", props, [resolve(x)]);
}
function snapshot(props, trigger, x) {
  return createNode("snapshot", props, [resolve(trigger), resolve(x)]);
}
function scope(props, ...args) {
  return createNode("scope", props, args.map(resolve));
}
function fft(props, x) {
  return createNode("fft", props, [resolve(x)]);
}
function capture(props, g, x) {
  return createNode("capture", props, [resolve(g), resolve(x)]);
}

// lib/dynamics.ts
var dynamics_exports = {};
__export(dynamics_exports, {
  compress: () => compress,
  skcompress: () => skcompress
});

// lib/math.ts
var math_exports = {};
__export(math_exports, {
  abs: () => abs,
  add: () => add,
  and: () => and,
  asinh: () => asinh,
  ceil: () => ceil,
  cos: () => cos,
  div: () => div,
  eq: () => eq,
  exp: () => exp,
  floor: () => floor,
  ge: () => ge,
  geq: () => geq,
  identity: () => identity,
  le: () => le,
  leq: () => leq,
  ln: () => ln,
  log: () => log,
  log2: () => log2,
  max: () => max2,
  min: () => min2,
  mod: () => mod,
  mul: () => mul,
  or: () => or,
  pow: () => pow,
  round: () => round,
  sin: () => sin,
  sqrt: () => sqrt,
  sub: () => sub2,
  tan: () => tan,
  tanh: () => tanh
});
function identity(props, x) {
  if (isNode3(x)) {
    return createNode("in", props, [x]);
  }
  return createNode("in", props, []);
}
function sin(x) {
  return createNode("sin", {}, [resolve(x)]);
}
function cos(x) {
  return createNode("cos", {}, [resolve(x)]);
}
function tan(x) {
  return createNode("tan", {}, [resolve(x)]);
}
function tanh(x) {
  return createNode("tanh", {}, [resolve(x)]);
}
function asinh(x) {
  return createNode("asinh", {}, [resolve(x)]);
}
function ln(x) {
  return createNode("ln", {}, [resolve(x)]);
}
function log(x) {
  return createNode("log", {}, [resolve(x)]);
}
function log2(x) {
  return createNode("log2", {}, [resolve(x)]);
}
function ceil(x) {
  return createNode("ceil", {}, [resolve(x)]);
}
function floor(x) {
  return createNode("floor", {}, [resolve(x)]);
}
function round(x) {
  return createNode("round", {}, [resolve(x)]);
}
function sqrt(x) {
  return createNode("sqrt", {}, [resolve(x)]);
}
function exp(x) {
  return createNode("exp", {}, [resolve(x)]);
}
function abs(x) {
  return createNode("abs", {}, [resolve(x)]);
}
function le(a, b) {
  return createNode("le", {}, [resolve(a), resolve(b)]);
}
function leq(a, b) {
  return createNode("leq", {}, [resolve(a), resolve(b)]);
}
function ge(a, b) {
  return createNode("ge", {}, [resolve(a), resolve(b)]);
}
function geq(a, b) {
  return createNode("geq", {}, [resolve(a), resolve(b)]);
}
function pow(a, b) {
  return createNode("pow", {}, [resolve(a), resolve(b)]);
}
function eq(a, b) {
  return createNode("eq", {}, [resolve(a), resolve(b)]);
}
function and(a, b) {
  return createNode("and", {}, [resolve(a), resolve(b)]);
}
function or(a, b) {
  return createNode("or", {}, [resolve(a), resolve(b)]);
}
function add(...args) {
  return createNode("add", {}, args.map(resolve));
}
function sub2(...args) {
  return createNode("sub", {}, args.map(resolve));
}
function mul(...args) {
  return createNode("mul", {}, args.map(resolve));
}
function div(...args) {
  return createNode("div", {}, args.map(resolve));
}
function mod(...args) {
  return createNode("mod", {}, args.map(resolve));
}
function min2(...args) {
  return createNode("min", {}, args.map(resolve));
}
function max2(...args) {
  return createNode("max", {}, args.map(resolve));
}

// lib/signals.ts
var signals_exports = {};
__export(signals_exports, {
  db2gain: () => db2gain,
  gain2db: () => gain2db,
  hann: () => hann,
  ms2samps: () => ms2samps,
  select: () => select,
  tau2pole: () => tau2pole
});
var el = __spreadValues(__spreadValues({}, core_exports), math_exports);
function ms2samps(t) {
  return el.mul(el.sr(), el.div(t, 1e3));
}
function tau2pole(t) {
  return el.exp(el.div(-1, el.mul(t, el.sr())));
}
function db2gain(db) {
  return el.pow(10, el.mul(db, 1 / 20));
}
function gain2db(gain) {
  return select(el.ge(gain, 0), el.max(-120, el.mul(20, el.log(gain))), -120);
}
function select(g, a, b) {
  return el.add(el.mul(g, a), el.mul(el.sub(1, g), b));
}
function hann(t) {
  return el.mul(0.5, el.sub(1, el.cos(el.mul(2 * Math.PI, t))));
}

// lib/dynamics.ts
var el2 = __spreadValues(__spreadValues(__spreadValues({}, core_exports), math_exports), signals_exports);
function compress(attackMs, releaseMs, threshold, ratio, sidechain, xn) {
  const env2 = el2.env(el2.tau2pole(el2.mul(1e-3, attackMs)), el2.tau2pole(el2.mul(1e-3, releaseMs)), sidechain);
  const envDecibels = el2.gain2db(env2);
  const adjustedRatio = el2.sub(1, el2.div(1, ratio));
  const gain = el2.mul(adjustedRatio, el2.sub(threshold, envDecibels));
  const cleanGain = el2.min(0, gain);
  const compressedGain = el2.db2gain(cleanGain);
  return el2.mul(xn, compressedGain);
}
function skcompress(attackMs, releaseMs, threshold, ratio, kneeWidth, sidechain, xn) {
  const env2 = el2.env(el2.tau2pole(el2.mul(1e-3, attackMs)), el2.tau2pole(el2.mul(1e-3, releaseMs)), sidechain);
  const envDecibels = el2.gain2db(env2);
  const lowerKneeBound = el2.sub(threshold, el2.div(kneeWidth, 2));
  const upperKneeBound = el2.add(threshold, el2.div(kneeWidth, 2));
  const isInSoftKneeRange = el2.and(el2.geq(envDecibels, lowerKneeBound), el2.leq(envDecibels, upperKneeBound));
  const adjustedRatio = el2.sub(1, el2.div(1, ratio));
  const gain = el2.select(isInSoftKneeRange, el2.mul(el2.div(adjustedRatio, 2), el2.mul(el2.div(el2.sub(envDecibels, lowerKneeBound), kneeWidth), el2.sub(lowerKneeBound, envDecibels))), el2.mul(adjustedRatio, el2.sub(threshold, envDecibels)));
  const cleanGain = el2.min(0, gain);
  const compressedGain = el2.db2gain(cleanGain);
  return el2.mul(xn, compressedGain);
}

// lib/envelopes.ts
var envelopes_exports = {};
__export(envelopes_exports, {
  adsr: () => adsr
});

// lib/filters.ts
var filters_exports = {};
__export(filters_exports, {
  allpass: () => allpass,
  bandpass: () => bandpass,
  dcblock: () => dcblock,
  df11: () => df11,
  highpass: () => highpass,
  highshelf: () => highshelf,
  lowpass: () => lowpass,
  lowshelf: () => lowshelf,
  notch: () => notch,
  peak: () => peak,
  pink: () => pink,
  sm: () => sm,
  smooth: () => smooth,
  zero: () => zero
});
var el3 = __spreadValues(__spreadValues(__spreadValues({}, core_exports), math_exports), signals_exports);
function smooth(p, x) {
  return el3.pole(p, el3.mul(el3.sub(1, p), x));
}
function sm(x) {
  return smooth(el3.tau2pole(0.02), x);
}
function zero(b0, b1, x) {
  return el3.sub(el3.mul(b0, x), el3.mul(b1, el3.z(x)));
}
function dcblock(x) {
  return el3.pole(0.995, zero(1, 1, x));
}
function df11(b0, b1, a1, x) {
  return el3.pole(a1, zero(b0, b1, x));
}
function lowpass(fc, q, x) {
  return el3.svf({ mode: "lowpass" }, fc, q, x);
}
function highpass(fc, q, x) {
  return el3.svf({ mode: "highpass" }, fc, q, x);
}
function bandpass(fc, q, x) {
  return el3.svf({ mode: "bandpass" }, fc, q, x);
}
function notch(fc, q, x) {
  return el3.svf({ mode: "notch" }, fc, q, x);
}
function allpass(fc, q, x) {
  return el3.svf({ mode: "allpass" }, fc, q, x);
}
function peak(fc, q, gainDecibels, x) {
  return el3.svfshelf({ mode: "peak" }, fc, q, gainDecibels, x);
}
function lowshelf(fc, q, gainDecibels, x) {
  return el3.svfshelf({ mode: "lowshelf" }, fc, q, gainDecibels, x);
}
function highshelf(fc, q, gainDecibels, x) {
  return el3.svfshelf({ mode: "highshelf" }, fc, q, gainDecibels, x);
}
function pink(x) {
  let clip = (min3, max3, x2) => el3.min(max3, el3.max(min3, x2));
  return clip(-1, 1, el3.mul(el3.db2gain(-30), el3.add(el3.pole(0.99765, el3.mul(x, 0.099046)), el3.pole(0.963, el3.mul(x, 0.2965164)), el3.pole(0.57, el3.mul(x, 1.0526913)), el3.mul(0.1848, x))));
}

// lib/envelopes.ts
var el4 = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, core_exports), math_exports), filters_exports), signals_exports);
function adsr(attackSec, decaySec, sustain, releaseSec, gate) {
  let [a, d, s, r, g] = [attackSec, decaySec, sustain, releaseSec, gate];
  let atkSamps = el4.mul(a, el4.sr());
  let atkGate = el4.le(el4.counter(g), atkSamps);
  let targetValue = el4.select(g, el4.select(atkGate, 1, s), 0);
  let t60 = el4.max(1e-4, el4.select(g, el4.select(atkGate, a, d), r));
  let p = el4.tau2pole(el4.div(t60, 6.91));
  return el4.smooth(p, targetValue);
}

// lib/mc.ts
var mc_exports = {};
__export(mc_exports, {
  capture: () => capture2,
  sample: () => sample2,
  sampleseq: () => sampleseq3,
  sampleseq2: () => sampleseq22,
  table: () => table2
});
var import_invariant2 = __toESM(require("invariant"), 1);
function sample2(props, gate) {
  let _a = props, { channels } = _a, other = __objRest(_a, ["channels"]);
  (0, import_invariant2.default)(typeof channels === "number" && channels > 0, "Must provide a positive number channels prop");
  return unpack(createNode("mc.sample", other, [resolve(gate)]), channels);
}
function sampleseq3(props, time2) {
  let _a = props, { channels } = _a, other = __objRest(_a, ["channels"]);
  (0, import_invariant2.default)(typeof channels === "number" && channels > 0, "Must provide a positive number channels prop");
  return unpack(createNode("mc.sampleseq", other, [resolve(time2)]), channels);
}
function sampleseq22(props, time2) {
  let _a = props, { channels } = _a, other = __objRest(_a, ["channels"]);
  (0, import_invariant2.default)(typeof channels === "number" && channels > 0, "Must provide a positive number channels prop");
  return unpack(createNode("mc.sampleseq2", other, [resolve(time2)]), channels);
}
function table2(props, t) {
  let _a = props, { channels } = _a, other = __objRest(_a, ["channels"]);
  (0, import_invariant2.default)(typeof channels === "number" && channels > 0, "Must provide a positive number channels prop");
  return unpack(createNode("mc.table", other, [resolve(t)]), channels);
}
function capture2(props, g, ...args) {
  let _a = props, { channels } = _a, other = __objRest(_a, ["channels"]);
  (0, import_invariant2.default)(typeof channels === "number" && channels > 0, "Must provide a positive number channels prop");
  return unpack(createNode("mc.capture", other, [resolve(g), ...args.map(resolve)]), channels);
}

// lib/oscillators.ts
var oscillators_exports = {};
__export(oscillators_exports, {
  blepsaw: () => blepsaw,
  blepsquare: () => blepsquare,
  bleptriangle: () => bleptriangle,
  cycle: () => cycle,
  noise: () => noise,
  pinknoise: () => pinknoise,
  saw: () => saw,
  square: () => square,
  train: () => train,
  triangle: () => triangle
});
var el5 = __spreadValues(__spreadValues(__spreadValues({}, core_exports), math_exports), filters_exports);
function train(rate) {
  return el5.le(el5.phasor(rate), 0.5);
}
function cycle(rate) {
  return el5.sin(el5.mul(2 * Math.PI, el5.phasor(rate)));
}
function saw(rate) {
  return el5.sub(el5.mul(2, el5.phasor(rate)), 1);
}
function square(rate) {
  return el5.sub(el5.mul(2, train(rate)), 1);
}
function triangle(rate) {
  return el5.mul(2, el5.sub(0.5, el5.abs(saw(rate))));
}
function blepsaw(rate) {
  return createNode("blepsaw", {}, [resolve(rate)]);
}
function blepsquare(rate) {
  return createNode("blepsquare", {}, [resolve(rate)]);
}
function bleptriangle(rate) {
  return createNode("bleptriangle", {}, [resolve(rate)]);
}
function noise(props) {
  return el5.sub(el5.mul(2, el5.rand(props)), 1);
}
function pinknoise(props) {
  return el5.pink(noise(props));
}

// src/Events.ts
var import_eventemitter3 = __toESM(require("eventemitter3"), 1);
var Events_default = class extends import_eventemitter3.default {
  constructor() {
    super();
  }
};

// index.ts
var stdlib = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, core_exports), dynamics_exports), envelopes_exports), filters_exports), math_exports), oscillators_exports), signals_exports), {
  mc: mc_exports,
  "const": constant,
  "in": identity
});
var InstructionTypes = {
  CREATE_NODE: 0,
  APPEND_CHILD: 2,
  SET_PROPERTY: 3,
  ACTIVATE_ROOTS: 4,
  COMMIT_UPDATES: 5
};
var Delegate = class {
  constructor() {
    this.nodeMap = /* @__PURE__ */ new Map();
    this.currentActiveRoots = /* @__PURE__ */ new Set();
    this.clear();
  }
  clear() {
    this.nodesAdded = 0;
    this.nodesRemoved = 0;
    this.edgesAdded = 0;
    this.propsWritten = 0;
    this.batch = {
      createNode: [],
      appendChild: [],
      setProperty: [],
      activateRoots: [],
      commitUpdates: []
    };
  }
  getNodeMap() {
    return this.nodeMap;
  }
  createNode(hash, type) {
    this.nodesAdded++;
    this.batch.createNode.push([InstructionTypes.CREATE_NODE, hash, type]);
  }
  appendChild(parentHash, childHash, childOutputChannel) {
    this.edgesAdded++;
    this.batch.appendChild.push([InstructionTypes.APPEND_CHILD, parentHash, childHash, childOutputChannel]);
  }
  setProperty(hash, key, value) {
    this.propsWritten++;
    this.batch.setProperty.push([InstructionTypes.SET_PROPERTY, hash, key, value]);
  }
  activateRoots(roots) {
    let alreadyActive = roots.length === this.currentActiveRoots.size && roots.every((root) => this.currentActiveRoots.has(root));
    if (!alreadyActive) {
      this.batch.activateRoots.push([InstructionTypes.ACTIVATE_ROOTS, roots]);
      this.currentActiveRoots = new Set(roots);
    }
  }
  commitUpdates() {
    this.batch.commitUpdates.push([InstructionTypes.COMMIT_UPDATES]);
  }
  getPackedInstructions() {
    return [
      ...this.batch.createNode,
      ...this.batch.appendChild,
      ...this.batch.setProperty,
      ...this.batch.activateRoots,
      ...this.batch.commitUpdates
    ];
  }
};
function now() {
  if (typeof performance === "undefined") {
    return Date.now();
  }
  return performance.now();
}
var Renderer = class {
  constructor(sendMessage) {
    this._delegate = new Delegate();
    this._sendMessage = sendMessage;
    this._nextRefId = 0;
  }
  createRef(kind, props, children) {
    let key = `__refKey:${this._nextRefId++}`;
    let node = createNode(kind, Object.assign({ key }, props), children);
    let setter = (newProps) => {
      if (!this._delegate.nodeMap.has(node.hash)) {
        throw new Error("Cannot update a ref that has not been mounted; make sure you render your node first");
      }
      const nodeMapCopy = this._delegate.nodeMap.get(node.hash);
      this._delegate.clear();
      updateNodeProps(this._delegate, node.hash, nodeMapCopy.props, newProps);
      this._delegate.commitUpdates();
      const instructions = this._delegate.getPackedInstructions();
      return Promise.resolve(this._sendMessage(instructions));
    };
    return [node, setter];
  }
  render(...args) {
    return this.renderWithOptions({ rootFadeInMs: 20, rootFadeOutMs: 20 }, ...args);
  }
  renderWithOptions(options, ...args) {
    const t0 = now();
    this._delegate.clear();
    renderWithDelegate2(this._delegate, args.map(resolve), options.rootFadeInMs, options.rootFadeOutMs);
    const t1 = now();
    const instructions = this._delegate.getPackedInstructions();
    return Promise.resolve(this._sendMessage(instructions)).then((result) => {
      return {
        result,
        nodesAdded: this._delegate.nodesAdded,
        edgesAdded: this._delegate.edgesAdded,
        propsWritten: this._delegate.propsWritten,
        elapsedTimeMs: t1 - t0
      };
    });
  }
  prune(nodeIds) {
    nodeIds.forEach((n) => {
      this._delegate.nodeMap.delete(n);
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Delegate,
  EventEmitter,
  Renderer,
  createNode,
  el,
  isNode,
  renderWithDelegate,
  resolve,
  stdlib,
  unpack
});
